Commands

dotnet new web -n ProductService
dotnet run

Endpoints:

GET
http://localhost:5044/api/products

GET by id
http://localhost:5044/api/products/2

POST
http://localhost:5044/api/products
{
    "id": 4,
    "name": "Product D",
    "price": 123.99
}

PUT by Id
http://localhost:5044/api/products/3
{
    "id": 3,
    "name": "Product CC",
    "price": 123.99
}

DELETE
http://localhost:5044/api/products/3

GET
http://localhost:5044/api/products


Create Docker Image for Product Microservices

Build Docker Image

Run command at same directory level of Dockerfile
	docker build -t productservice .

---
See a list of all images available on your machine
	docker images

---
Run Docker image:
docker run -d -p 8080:80 --name productservicecontainer productservice

---
Check if the container is running by executing:
docker ps

---
Open your browser and navigate to
http://localhost:8080

http://localhost:8080/api/products
[{"id":1,"name":"Product A","price":12.99},{"id":2,"name":"Product B","price":23.99},{"id":3,"name":"Product C","price":34.99}]

---
Stop Running Container:
docker stop productservicecontainer
docker rm productservicecontainer
docker ps

---
Another good approach to run docker image:
docker run -it --rm -p 8080:80 --name productservicecontainer productservice

This command tells Docker to run a container in -it interactive mode - we used also run detached mode (-d).

Hit Endpoint:
http://localhost:8080/api/products
[{"id":1,"name":"Product A","price":12.99},{"id":2,"name":"Product B","price":23.99},{"id":3,"name":"Product C","price":34.99}]

goto command prompt:
CTRL+C

Check running images on docker:
docker ps


Push Docker Image to Docker Hub for Product Microservices
---
Docker Hub is a central place to upload Docker images. 
>
Create a Docker Hub account if you don't have one: 
	https://hub.docker.com/    

>
Step 1: Log in to Docker Hub
Open a terminal and run the following command to log in to Docker Hub:

	docker login

Enter your Docker Hub username and password when prompted.

Username: subhapy
Password: 
Login Succeeded

>
Step 2: Tag your Docker image

Find the IMAGE ID of your local Docker image by running:
	docker images

Tag your Docker image with your Docker Hub username and the desired repository name:
	docker tag productservice subhapy/productservice:latest

See tagged image
	docker images

>
Step 3: Push the Docker image to Docker Hub
Push the tagged Docker image to your Docker Hub repository:
	docker push subhapy/productservice:latest

Check
	https://hub.docker.com/
See
	https://hub.docker.com/repository/docker/mehmetozkaya/productservice/general

Getting Started with Minikube
----
>
Start Docker Desktop

>
Start your minikube cluster
	minikube start

>
Interact with your cluster
	kubectl get po -A

Alternative
	minikube kubectl -- get po -A

>
See that our K8s is up and running

>
See dashboard
	minikube dashboard


ASP.NET Container Expose Port - CONFIGURE TO LISTEN - 0.0.0.0:8080
---

Todo List:
Edit Program.cs
Build Docker Image
Run Docker Container
Test running docker container on local docker env
Tag Docker Image
Publish image to a Registry: Docker Hub

-----
>
goto Program.cs

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddSingleton<List<Product>>();

	// Add the following for Kubernetes Deployment
	var port = Environment.GetEnvironmentVariable("PORT") ?? "8080";
	var url = $"http://0.0.0.0:{port}";
	builder.WebHost.UseUrls(url);

var app = builder.Build();

ADDED
	// Add the following for Kubernetes Deployment
	var port = Environment.GetEnvironmentVariable("PORT") ?? "8080";
	var url = $"http://0.0.0.0:{port}";
	builder.WebHost.UseUrls(url);

>>
OTHER WAYS:
 > dockerfile
add ENV varible into DockerFile
	https://github.com/dotnet/dotnet-docker/issues/3968

 "environmentVariables": {
        "ASPNETCORE_URLS": "https://+:443;http://+:80",
        "ASPNETCORE_HTTPS_PORT": "44360"
      },

 >k8s deployment ENV variable inject
 	https://www.youtube.com/watch?v=63FLcPHUCPM
 	dk 46.11

 	kestrel__endpoints__http__url
 	http://0.0.0.0:80

-----
goto Code location

>>
Build Docker Image

Run command at same directory level of Dockerfile:
    docker build -t productservice .

See available images:
    docker images

>>
Run Docker Image
You can run your app in a container using the following command:

    docker run -d -p 8080:80 --name productservicecontainer productservice

Check if the container is running by executing:
    docker ps

Hit Endpoint:
http://localhost:8080/api/products
[{"id":1,"name":"Product A","price":12.99},{"id":2,"name":"Product B","price":23.99},{"id":3,"name":"Product C","price":34.99}]

Stop Running Container:
    docker stop productservicecontainer
    docker rm productservicecontainer

>>
Publish image to a Registry: Docker Hub

Docker Hub is a central place to upload Docker images. 
Many products, including Microsoft Azure, can create containers based on images in Docker Hub.

Create a Docker Hub account if you don't have one: 
	https://hub.docker.com/    

>
Step 1: Log in to Docker Hub
Open a terminal or command prompt and run the following command to log in to Docker Hub:

	docker login

Enter your Docker Hub username and password when prompted.

Username: mehmetozkaya
Password: 
Login Succeeded

>
Step 2: Tag your Docker image

Find the IMAGE ID of your local Docker image by running:
	docker images

Tag your Docker image with your Docker Hub username and the desired repository name:
	docker tag productservice mehmetozkaya/productservice:latest

see tagged image
	docker images

>
Step 3: Push the Docker image to Docker Hub
Push the tagged Docker image to your Docker Hub repository:
	docker push mehmetozkaya/productservice:latest

Check
	https://hub.docker.com/
See
	https://hub.docker.com/repository/docker/mehmetozkaya/productservice/general


-----
Ready to deploy into minikube


Creating a Pod Definition
----
>1
Make sure that you have updated image accordingly.

Retrieve the Product microservice container images
	https://hub.docker.com/repository/docker/mehmetozkaya/productservice/general

The code for the Product ms and the Dockerfiles to build the container images has already been created in the last hands-on labs.
	docker pull mehmetozkaya/productservice:latest

>2
The Pod
A container running in Kubernetes is called a Pod. 
A Pod is basically a running container on a Node or VM. It can be more. 

Pod definition can be created via the kubectl command imperatively from arguments
 or declaratively from a configuration file. 
Use the kubectl command to write our configuration files. 

>3
product-pod.yaml

apiVersion: v1
kind: Pod
metadata:
  name: product-pod
spec:
  containers:
  - name: product
    image: mehmetozkaya/productservice:latest
    ports:
    - containerPort: 8080

Creating a Pod Definition
----
product-pod.yaml
>
Open 2. terminal to watch created pods on K8s
	kubectl get pods -w

>
Apply the configuration
    kubectl apply -f product-pod.yaml

>
See Watch 

kubectl get pods -w
NAME         READY   STATUS    RESTARTS   AGE
my-app-pod   0/1     Pending   0          0s
my-app-pod   0/1     Pending   0          0s
my-app-pod   0/1     ContainerCreating   0          
my-app-pod   1/1     Running             0      

>
kubectl get pod
NAME         READY   STATUS    RESTARTS   AGE
my-app-pod   1/1     Running   0          63s

>
Expose the Pod
    kubectl port-forward product-pod 8080:8080

Forwarding from 127.0.0.1:8080 -> 8080
Forwarding from [::1]:8080 -> 8080

You can now access the microservice at http://localhost:8080.

>
SEE DEPLOYED MICROSERVICE ON K8S WITH POD

http://localhost:8080/api/products

[{"id":1,"name":"Product A","price":12.99},{"id":2,"name":"Product B","price":23.99},{"id":3,"name":"Product C","price":34.99}]

>
Stop Pod
    CTRL+C

>
Clean Up

kubectl delete pod product-pod
or
kubectl delete -f .\product-pod.yaml

Create a Deployment on Kubernetes
----
product-deploy.yaml


Create and Apply Deployment on Kubernetes
----
product-deploy.yaml

Open 2. terminal to watch created pods on K8s
	kubectl get pods -w

>
Apply the configuration
    kubectl apply -f product-deploy.yaml

>
See Watch 

kubectl get pods -w
NAME         READY   STATUS    RESTARTS   AGE
my-app-pod   0/1     Pending   0          0s
my-app-pod   0/1     Pending   0          0s
my-app-pod   0/1     ContainerCreating   0          
my-app-pod   1/1     Running             0      

>
kubectl get pod
NAME         READY   STATUS    RESTARTS   AGE
my-app-pod   1/1     Running   0          63s

>>
Expose the Pod

Create Kubernetes "Service" Objects

Create a Service on Kubernetes
----
product-service.yaml


Apply a Service in K8s
----
product-service.yaml

>
Apply the configuration
    kubectl apply -f product-service.yaml

>
See all 

kubectl get all
NAME                           READY   STATUS    RESTARTS   AGE
pod/product-5c4647dd7c-lczvv   1/1     Running   0          11m
pod/product-5c4647dd7c-nmmk4   1/1     Running   0          11m
pod/product-5c4647dd7c-tg8jl   1/1     Running   0          11m

NAME                      TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
service/kubernetes        ClusterIP      10.96.0.1       <none>        443/TCP        96m
service/product-service   LoadBalancer   10.98.222.106   <pending>     80:31240/TCP   24s

NAME                      READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/product   3/3     3            3           11m

NAME                                 DESIRED   CURRENT   READY   AGE
replicaset.apps/product-5c4647dd7c   3         3         3       11m

>
Notice the service/product-service --type argument has a value of LoadBalancer. 
This service type is implemented by the cloud-controller-manager which is part of the Kubernetes control plane. 

>
Expose the Service
To invoke our pod with this service definition, we need a tunnel for K8s LoadBalancer IP.

kubectl port-forward service/product-service 7080:8080

> SEE RESULT
http://127.0.0.1:7080/api/products
[{"id":1,"name":"Product A","price":12.99},{"id":2,"name":"Product B","price":23.99},{"id":3,"name":"Product C","price":34.99}]

>> Expose Service with Minikube

Run the following command to expose the service:
	minikube service product-service

PS C:\dev\ProductMicroservice\k8s> minikube service product-service
|-----------|-----------------|-------------|---------------------------|
| NAMESPACE |      NAME       | TARGET PORT |            URL            |
|-----------|-----------------|-------------|---------------------------|
| default   | product-service |          80 | http://192.168.49.2:31240 |
|-----------|-----------------|-------------|---------------------------|
🏃  Starting tunnel for service product-service.
|-----------|-----------------|-------------|------------------------|
| NAMESPACE |      NAME       | TARGET PORT |          URL           |
|-----------|-----------------|-------------|------------------------|
| default   | product-service |             | http://127.0.0.1:56091 |
|-----------|-----------------|-------------|------------------------|


>
SEE RESULT:

http://127.0.0.1:56268/api/products
[{"id":1,"name":"Product A","price":12.99},{"id":2,"name":"Product B","price":23.99},{"id":3,"name":"Product C","price":34.99}]

Combined Way of Creating Deployment and Services for Microservices
----
product.yaml

>
Apply the configuration
    kubectl apply -f .\product.yaml

deployment.apps/product unchanged
service/product-service unchanged

See that 2 files affected. You can delete and re-create your deployment and service objects with kubectl delete and apply commands.
    kubectl delete -f .\product.yaml

Verify
    kubectl get all


Create Ingress for External Access of Product Microservice
----
No longer need a service type of LoadBalancer since the service does not need to be accessible from the internet. 
It only needs to be accessible from the Ingress Controller (internal to the cluster) 
  so we can change the service type to ClusterIP.

Update your service.yaml file to look like this:

    Remove type
    Create Ingress into product.yaml file

We have created Ingress object and referring to our service object which is product-service.
and host address is product.local

>
So we should add this dns address into our host file.

Update your hosts file (/etc/hosts on Linux and macOS or C:\Windows\System32\drivers\etc\hosts on Windows) to add the following line:

First get IP of minikube
minikube ip
192.168.49.2

>
Add this line:

# Added by Minikube Custom Domain
192.168.49.2 product.local

>>
Now we are ready to deploy our ingress.
But before that we should active Ingress addons into our minikube installment.

See all list
	minikube addons list

Activate Ingress for our local minikube
	minikube addons enable ingress

>>
Re-apply the app service manifest.
Re-create all objects:

kubectl delete -f product.yaml
kubectl apply -f product.yaml

> See all
kubectl get all

kubectl get ingress
NAME              CLASS   HOSTS           ADDRESS        PORTS   AGE
product-ingress   nginx   product.local   192.168.49.2   80      3m29s

>
Access dns adress

product.local

>
SEE RESULT:
http://product.local/api/products
[{"id":1,"name":"Product A","price":12.99},{"id":2,"name":"Product B","price":23.99},{"id":3,"name":"Product C","price":34.99}]

Create ConfigMaps and Secrets for Microservice
----
Create a ConfigMap to store a basic configuration parameter, such as the log_level. 
Create a file named log-level-configmap.yaml

GOTO
  product.yaml

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: log-level-configmap
data:
  log_level: "Information"

---
Create the Secret
use a Secret to create api-key secret inside the pod.
encode the secret value in base64:

> open bash on vscode

echo -n 'product-api-key' | base64
cHJvZHVjdC1hcGkta2V5

>
Copy the output and create secret into product.yaml file

---
apiVersion: v1
kind: Secret
metadata:
  name: api-key-secret
type: Opaque
data:
  api_key: cHJvZHVjdC1hcGkta2V5

>>
Update the deployment object to use the ConfigMap and Secret values as environment variables in the container:

--product.yaml

added below part into deployment:

 env:
    - name: LOG_LEVEL
      valueFrom:
        configMapKeyRef:
          name: log-level-configmap
          key: log_level
    - name: API_KEY
      valueFrom:
        secretKeyRef:
          name: api-key-secret
          key: api_key

See that our pod injected 2 ENV Variables, 1 from configmap another from secret.

>>
Apply the updated all Deployment:\k8s> 
    kubectl apply -f .\product.yaml

	deployment.apps/product configured
	service/product-service unchanged
	ingress.networking.k8s.io/product-ingress unchanged
	configmap/log-level-configmap created
	secret/api-key-secret created

>Check

kubectl get secret
NAME             TYPE     DATA   AGE
api-key-secret   Opaque   1      27s

kubectl get configmap
NAME                  DATA   AGE
kube-root-ca.crt      1      25h
log-level-configmap   1      40s

>>
Modify .NET application to read these environment variables and use them as needed.
These are typical ENV variables that we can use into our application.

goto Program.cs

Show how to get these values:

var builder = WebApplication.CreateBuilder(args);

var logLevel = Environment.GetEnvironmentVariable("LOG_LEVEL");
var apiKey = Environment.GetEnvironmentVariable("API_KEY");

So we can ConfigureLogging as per these logLevel and add api key into controllers.


Scale a Container Instance in Kubernetes
----
Start with watch pods
	kubectl get pod -w

Use the kubectl scale command to update the deployment with a number of pods to create.
	kubectl scale --replicas=5 deployment/product

>
See watch - new 2 pod creating
product-deploy-5d5ccb7569-khfs6   0/1     ContainerCreating   0          0s
product-deploy-5d5ccb7569-qkrzn   0/1     ContainerCreating   0          0s

>
See latest pods
	kubectl get pod

>>
if there's a failure Kubernetes will automatically restart the pods that were running before the failure.
Let's see this resilience in action by deleting pod and then verifying that Kubernetes has restarted it.

kubectl get pods
product-deploy-5d5ccb7569-khfs6   0/1     ContainerCreating   0          0s
product-deploy-5d5ccb7569-qkrzn   0/1     ContainerCreating   0          0s

>
Delete the pod by using the kubectl delete command. 
  kubectl delete pod product-5b6cc765c4-hjpx4

>see
immediately stating the pod has been deleted.
  kubectl get pods

random string following the pod name has changed. 
Indicating the pod is a new instance.

>>
To scale the instance back down, run the following command.

	kubectl scale --replicas=1 deployment/product

See WATCH

product-deploy-5d5ccb7569-j9gvl   0/1     Terminating         0          2m26s
product-deploy-5d5ccb7569-khfs6   0/1     Terminating         0          78s
product-deploy-5d5ccb7569-khfs6   0/1     Terminating         0          78s
product-deploy-5d5ccb7569-khfs6   0/1     Terminating         0          78s
product-deploy-5d5ccb7569-4dcr8   0/1     Terminating         0          2m27s
product-deploy-5d5ccb7569-4dcr8   0/1     Terminating         0          2m27s
product-deploy-5d5ccb7569-4dcr8   0/1     Terminating         0          2m27s
product-deploy-5d5ccb7569-qkrzn   0/1     Terminating         0          78s
product-deploy-5d5ccb7569-qkrzn   0/1     Terminating         0          79s

Both of these approaches modify the running configuration 
  manually run kubectl scale
  or change replica number.

Solution: Auto-Scaling
Kubernetes Deploy and Service with Minikube
----
>
Start
  minikube start

>
Interact with your cluster
  minikube dashboard

>
Deploy applications
Create a sample deployment and expose it on port 8080:
  kubectl create deployment hello-minikube --image=subhapy/productservice:latest
  kubectl expose deployment hello-minikube --type=NodePort --port=8080


>Check service
The easiest way to access this service is to let minikube launch a web browser for you:
	kubectl get services hello-minikube

	minikube service hello-minikube

SEE - WORKED !
http://127.0.0.1:62162/api/products
[{"id":1,"name":"Product A","price":12.99},{"id":2,"name":"Product B","price":23.99},{"id":3,"name":"Product C","price":34.99}]

>
Alternatively, use kubectl to forward the port:
	kubectl port-forward service/hello-minikube 7080:8080

Your application is now available at http://localhost:7080/.

SEE- WORKED !
http://localhost:7080/api/products
[{"id":1,"name":"Product A","price":12.99},{"id":2,"name":"Product B","price":23.99},{"id":3,"name":"Product C","price":34.99}]

Clean up resources
----
>1
Delete host address
	C:\Windows\System32\drivers\etc\hosts

>2	
	kubectl delete deployment my-app
	kubectl delete service my-app-service
	kubectl delete pod my-app-pod
	kubectl delete ingress my-app-ingress

Since we can't just delete the pods, we have to delete the deployments.
	kubectl delete -f ./product.yaml

>3
Finally, stop Minikube with the command:
	minikube stop

Hands-on Lab: Deploy Product Microservices with Helm Charts
----
Create a simple Helm chart for the Product microservice we previously deployed to Kubernetes. 

>
Before that make sure that your docker and minikube is started
	docker start
	minikube start
	kubectl get pod

>
goto cmd for
  C:\dev\lecture154\helm> 

>
Create a new Helm chart:
Run the following command to create a new Helm chart named productservice:
  helm create productservice

This command will generate a new directory called productservice with the basic structure of a Helm chart.

>
See folder structure

helm/productservice

	see values.yaml, Chart.yaml ...

>>
Update the chart metadata:
Open the Chart.yaml file in the productservice directory, 
  and update it with the relevant information about Product microservice:

apiVersion: v2
name: product-app
description: A Helm chart for Product microservice
type: application
version: 0.1.0
appVersion: 1.0.0

>>
Examine Generated files:

Charts.yaml
Values.yaml
Templates folder

>>
Update the default values:
Open the values.yaml file in the productservice directory, 
  and set the default values for the deployment, service, and container image:

replicaCount: 3

image:
  repository: mehmetozkaya/productservice
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: "latest"
...
service:
  type: LoadBalancer
  port: 8080
  targetPort: 8080

...
These values are automatically map the deployment and service yaml files under templates folder.

>>
See how organize template parameters:
  image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
  imagePullPolicy: {{ .Values.image.pullPolicy }}

>>
Update the templates:
goto template file and see the content that will replace.

1 - service.yaml file
	put targetPort: {{ .Values.service.targetPort }}

ports:
    - port: {{ .Values.service.port }}
      targetPort: {{ .Values.service.targetPort }}
      protocol: TCP

2- remove health checks
	since we expose microservices
		api/products
			we can remove or change this
				otherwise our pods wont be start due to not become healty state
>
The idea is that when we generate k8s files 
	that we already developed before.

see k8s folder
	see deployment and service.yaml file

>>
Install the chart:
Run the command to install the Helm chart into your Kubernetes cluster:
	helm install productservice-release ./productservice

This will create a new release of your chart with the name productservice-release.

NAME: product-app-release
LAST DEPLOYED: Wed Apr 12 15:18:17 2023
NAMESPACE: default
REVISION: 1

NOTES:
1. Get the application URL by running these commands:
     NOTE: It may take a few minutes for the LoadBalancer IP to be available.
           You can watch the status of by running 'kubectl get --namespace default svc -w product-app-release'
  export SERVICE_IP=$(kubectl get svc --namespace default product-app-release --template "{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}")
  echo http://$SERVICE_IP:80

>>
Verify the deployment:
Run the following command to check the status of your release:
	helm list

You should see your productservice-release in the list of deployed releases.

Check deployed resources:
  kubectl get svc,deploy,pods
  kubectl get all

>>
Access the application:
To access the application, we'll need the create tunnel of the service with using kubectl port-forward command or minikube service command.

Port fwd
	minikube service productservice-release

See products
	url
	http://127.0.0.1:50643/api/products


>
Uninstall the chart:
When you are done testing your application, you can uninstall the release by running:
	helm uninstall productservice-release

See pods removed:
	kubectl get all

Download and Install Istio Service Mesh onto Minikube K8s cluster
----
>1
Go to the Istio release page to download the installation file for your OS, 
	or download and extract the latest release automatically (Linux or macOS):

	https://istio.io/latest/docs/setup/getting-started/#download
	https://github.com/istio/istio/releases	

	istio-1.xx-win.zip	

>2
Move to the Istio package directory. 
For example, if the package is istio-1.17.2:

$ cd istio-1.17.2

The installation directory contains:

Sample applications in samples/
The istioctl client binary in the bin/ directory.

C:\Users\PC\Downloads\istio-1.17.2-win\istio-1.17.2

>3
Add the istioctl client to your path (Linux or macOS):

$ export PATH=$PWD/bin:$PATH

Windows

Move 
	C:\Users\PC\Downloads\istioctl-1.17.2-win
		istioctl.exe

to our
	C:/tools folder
		istioctl.exe

>
Open wt
	istioctl
Install Istio Service Mesh
----
>0
Make sure that you have installed minikube and kubectl.

Start Docker
minikube start

kubectl get pod
kubectl get all

>1
For this installation, we use the demo configuration profile. 

Run Command:
	istioctl install --set profile=demo -y

✔ Istio core installed
✔ Istiod installed
✔ Egress gateways installed
✔ Ingress gateways installed
✔ Installation complete

>2
Add a namespace label to instruct Istio to automatically inject Envoy sidecar proxies when you deploy your application later:

Run Command:
	kubectl label namespace default istio-injection=enabled

namespace/default labeled

Deploy the Microservices Application
----
>1
Deploy the Bookinfo sample application:

Run Command:
	kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml

	kubectl apply -f .\bookinfo.yaml

service/details created
serviceaccount/bookinfo-details created
deployment.apps/details-v1 created
service/ratings created
serviceaccount/bookinfo-ratings created
deployment.apps/ratings-v1 created
service/reviews created
serviceaccount/bookinfo-reviews created
deployment.apps/reviews-v1 created
deployment.apps/reviews-v2 created
deployment.apps/reviews-v3 created
service/productpage created
serviceaccount/bookinfo-productpage created
deployment.apps/productpage-v1 created


>2
The application will start. 
As each pod becomes ready, the Istio sidecar will be deployed along with it.

Run Command:
	kubectl get services

NAME          TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
details       ClusterIP   10.0.0.212      <none>        9080/TCP   29s
kubernetes    ClusterIP   10.0.0.1        <none>        443/TCP    25m
productpage   ClusterIP   10.0.0.57       <none>        9080/TCP   28s
ratings       ClusterIP   10.0.0.33       <none>        9080/TCP   29s
reviews       ClusterIP   10.0.0.28       <none>        9080/TCP   29s

and

Run Command:
	kubectl get pods

NAME                              READY   STATUS    RESTARTS   AGE
details-v1-558b8b4b76-2llld       2/2     Running   0          2m41s
productpage-v1-6987489c74-lpkgl   2/2     Running   0          2m40s
ratings-v1-7dc98c7588-vzftc       2/2     Running   0          2m41s
reviews-v1-7f99cc4496-gdxfn       2/2     Running   0          2m41s
reviews-v2-7d79d5bd5d-8zzqd       2/2     Running   0          2m41s
reviews-v3-7dbcdcbc56-m8dph       2/2     Running   0          2m41s
reviews-v2-5d99885bc9-thx8b       0/2     PodInitializing   0             2m18s
reviews-v3-589cb4d56c-9xrfs       0/2     PodInitializing   0             2m18s

Re-run the previous command and wait until all pods report READY and STATUS Running before you go to the next step. This might take a few minutes depending on your platform.

Make sure that 2/2 pods created successfully.

Run Command:
PS C:\Users\PC> kubectl get pods
NAME                              READY   STATUS    RESTARTS      AGE
details-v1-6997d94bb9-4g69r       2/2     Running   0             3m1s
hello-minikube-5b8bbb84c7-6grrn   1/1     Running   2 (10m ago)   2d20h
productpage-v1-d4f8dfd97-f85s2    2/2     Running   0             3m
ratings-v1-b8f8fcf49-dhkz8        2/2     Running   0             3m
reviews-v1-5896f547f5-l52p9       2/2     Running   0             3m
reviews-v2-5d99885bc9-thx8b       2/2     Running   0             3m
reviews-v3-589cb4d56c-9xrfs       2/2     Running   0             3m

>3
Verify everything is working correctly up to this point. 
Run this command to see if the app is running inside the cluster and serving HTML pages by checking for the page title in the response:

bash script

$ kubectl exec "$(kubectl get pod -l app=ratings -o jsonpath='{.items[0].metadata.name}')" -c ratings -- curl -sS productpage:9080/productpage | grep -o "<title>.*</title>"

<title>Simple Bookstore App</title>
Open the Application to Outside Traffic
----
>1
Create file bookinfo-gateway.yaml

copy-paste
	https://raw.githubusercontent.com/istio/istio/release-1.17/samples/bookinfo/networking/bookinfo-gateway.yaml

>2
Associate this application with the Istio gateway:

Run Command:
$ kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml

$ kubectl apply -f .\bookinfo-gateway.yaml

gateway.networking.istio.io/bookinfo-gateway created
virtualservice.networking.istio.io/bookinfo created

>3
Ensure that there are no issues with the configuration:

$ istioctl analyze
✔ No validation issues found when analyzing namespace: default.

Warning [IST0103] (Pod default/hello-minikube-5b8bbb84c7-6grrn) The pod default/hello-minikube-5b8bbb84c7-6grrn is missing the Istio proxy.
Info [IST0118] (Service default/hello-minikube) Port name  (port: 8080, targetPort: 8080) doesn't follow the naming convention of Istio port.


>4
Determining the ingress IP and ports

Run this command in a new terminal window to start a Minikube tunnel that sends traffic to your Istio Ingress Gateway. 
This will provide an external load balancer, EXTERNAL-IP, for service/istio-ingressgateway.

Run Command:
$ minikube tunnel

>5
Set the ingress host and ports:
Set the INGRESS_HOST and INGRESS_PORT variables for accessing the gateway. Use the tabs to choose the instructions for your chosen platform:
Open git bash command and check below parameters:

$ export INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}'); export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="http2")].port}'); export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="https")].port}')

Ensure an IP address and ports were successfully assigned to each environment variable:

$ echo "$INGRESS_HOST"
127.0.0.1

$ echo "$INGRESS_PORT"
80

$ echo "$SECURE_INGRESS_PORT"
443


>6
Set GATEWAY_URL:

$ export GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT

Ensure an IP address and port were successfully assigned to the environment variable:

$ echo "$GATEWAY_URL"
192.168.99.100:32194

127.0.0.1:80

>7
Verify external access
Confirm that the Bookinfo application is accessible from outside.
Run the following command to retrieve the external address of the Bookinfo application.

$ echo "http://$GATEWAY_URL/productpage"

Paste the output from the previous command into your web browser.
open chrome
	http://127.0.0.1/productpage

See page came
	The Comedy of Errors !

View the dashboard - Deploy the Kiali dashboard, along with Prometheus, Grafana, and Jaeger
----
>1
We should download full folder on github, we can also do copy paste one-by-one all folders, but there is a short way to implement all folder.

Downloaded path:
	https://github.com/istio/istio/tree/release-1.17/samples/addons

Download folder:
	https://download-directory.github.io/

Downloaded !

give path and download zip file.
Extract files

>2
create "addons" folder under lecture folder  on vscode

copy paste all items into github to vs code folder
	https://github.com/istio/istio/tree/release-1.17/samples/addons

	kiali.yaml
	prometheus.yaml
	jaeger.yaml
	grafana.yaml

> Read
	Readme File

>
goto path
	copy and paste addons folder of k8s

>
Examine files
	kiali.yaml
	prometheus.yaml
	jaeger.yaml
	grafana.yaml

So now we are ready to apply this whole folder into our minikube kubernetes cluster over the istio service mesh.

>>
Install Kiali and the other addons and wait for them to be deployed.

Run Command:
$ kubectl apply -f .\addons\
$ kubectl rollout status deployment/kiali -n istio-system

Waiting for deployment "kiali" rollout to finish: 0 of 1 updated replicas are available...
deployment "kiali" successfully rolled out

>
Access the Kiali dashboard.

Run Command:
$ istioctl dashboard kiali


Analysis the Dashboard
----
>
Open new wt:
minikube tunnel

http://127.0.0.1/productpage

>
Open new wt:
istioctl dashboard kiali

>
To send a 100 requests to the productpage service, use the following command:

goto bash script
$ for i in $(seq 1 100); do curl -s -o /dev/null "http://10.103.184.40//productpage"; done


Uninstall Istio Workloads
----
When you’re finished the Bookinfo sample, uninstall and clean it up using the following command:

Run Command:
$ samples/bookinfo/platform/kube/cleanup.sh

See details
copy paste from here
	https://raw.githubusercontent.com/istio/istio/release-1.17/samples/bookinfo/platform/kube/cleanup.sh

create file into lecture folder
	cleanup.sh

>>
Run bash command

open bash

goto folder
	cd lecture

run command
	bash cleanup.sh

namespace = default

WAIT UNTIL cleanup message came
	using NAMESPACE=default
	virtualservice.networking.istio.io "bookinfo" deleted
	gateway.networking.istio.io "bookinfo-gateway" deleted
	Application cleanup may take up to one minute
	service "details" deleted
	serviceaccount "bookinfo-details" deleted
	deployment.apps "details-v1" deleted
	service "ratings" deleted
	serviceaccount "bookinfo-ratings" deleted
	deployment.apps "ratings-v1" deleted
	service "reviews" deleted
	serviceaccount "bookinfo-reviews" deleted
	deployment.apps "reviews-v1" deleted
	deployment.apps "reviews-v2" deleted
	deployment.apps "reviews-v3" deleted
	service "productpage" deleted
	serviceaccount "bookinfo-productpage" deleted
	deployment.apps "productpage-v1" deleted
	Application cleanup successful

>>
The Istio uninstall deletes the RBAC permissions and all resources hierarchically under the istio-system namespace. 
It is safe to ignore errors for non-existent resources because they may have been deleted hierarchically.

delete addons - powershell

Run Command:
	kubectl delete -f .\addons\
	istioctl uninstall -y --purge

>>
The istio-system namespace is not removed by default. 
If no longer needed, use the following command to remove it:

Run Command:
$ kubectl delete namespace istio-system

namespace "istio-system" deleted

>>
The label to instruct Istio to automatically inject Envoy sidecar proxies is not removed by default. 
If no longer needed, use the following command to remove it:

Run Command:
$ kubectl label namespace default istio-injection-

namespace/default labeled

>>
Finished !!